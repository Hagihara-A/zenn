---
title: "TypeScript人のためのPureScript入門"
emoji: "🦾"
type: "tech"
topics: ["PureScript", "TypeScript", "javascript"]
published: false
---

この記事は[PureScript Advent Calendar 2022](https://qiita.com/advent-calendar/2022/purescript) 12日目の記事です

この記事では、TypeScript習得者がPureScriptを勉強するときに躓きがちな概念について、TypeScriptを使った解釈を紹介します。
なお、詳細な文法の解説はしません。PureScriptの資料は少ないので、基礎から入門したい方は代わりにHaskellに入門することをお勧めします。HaskellとPureScriptは99%同じです。

# 免責
筆者は専門家ではないので間違った説明をしている場合があります。

# 関数呼び出し
PureScriptでの関数呼び出しにはかっこを付けません。TypeScriptで`func(a, b, c)`ならPureScriptでは`func a b c`のように呼び出します。

TypeScriptでの関数呼び出し
```ts
console.log("Hello PureScript!")
```
PureScriptでの関数呼び出し
```purs
log "Hello PureScript!"
```



# カリー化
カリー化とは以下のような関数を
```ts
const add = (a, b) => a + b;
add(5, 7) // 12
```

```ts
const add = (a) => (b) => a + b;
add(5)(7) // 12
```
のように書き換えることです。カリー化すると関数の部分適用を簡単に書けます。
例えば、カリー化されていない関数に最初の引数だけ適用しようとすると
```ts
const add = (a, b) => a + b;
const add5 = (b) => add(5, b);
add5(7) // 12
```
のように新しい関数を手書きする必要があります。しかし、関数がカリー化されていた場合、

```ts
const add = (a) => (b) => a + b;
const add5 = add(5);
add5(7) // 12
```
のように、コードの繰り返しを避けることができます。

これはReactでも便利で、
```ts
const add = (a, b) => a + b;
const add_a = useCallback((b) => add(a, b), [a]);
```
と書いていたものが、
```ts
const add = (a) => (b) => a + b;
const add_a = useMemo(() => add(a), [a]);
```
というようにすっきりかけます。

# PureScriptでの関数定義
先ほどのadd関数はPureScriptで以下のように定義できます。
```purs
add a b = a + b
```

PureScriptの関数はデフォルトでカリー化されていて、部分適用するには
```purs
add5 = add 5
```
とします。

# 型宣言
型宣言は`::`の後に続けます。先ほどのadd関数は以下のように型宣言出来ます。
```purs
add :: Int -> Int -> Int
add a b = a + b
```
引数を`->`でつなげて、最後に返り値を書きます。引数を`->`でつなげるのは関数がカリー化されているからです。例えば最初の引数だけ適用すると返り値は`Int -> Int`の関数になります。

# 代数的データ型
TypeScriptで以下のような型をかいたことがあると思います。
```ts
type State =
  | { type: "loading" }
  | { type: "resolve"; data: string }
  | { type: "reject"; error: string };
```

PureScriptだとこうなります。
```purs
data State = Loading | Resolve String | Reject String
```

このコードにおいて、`State`は型を表し、`Loading, Resolve, Reject`は`State`という型の値を作る関数を表します。`State`のことを「データ型」、`Loading, Resolve, Reject`は「値コンストラクタ」と呼びます。

TypeScriptで同じ意味のコードを書くならこうなります。
```ts
const Loading: State = { type: "loading" };
const Resolve = (data: string): State => ({ type: "resolve", data });
const Reject = (error: string): State => ({ type: "reject", error });
```

# 型クラス
型クラスというのは要はインターフェースです。PureScriptには`Eq`という型クラスがあります。これは「等値判定可能なデータ型」を表します。

PureScriptでは型クラスは以下のように書きます。
```purs
class Eq a where
  eq :: a -> a -> Boolean
```

同じことをTypeScriptで書くと、
```ts
interface Eq<a> {
  eq: (arg1: a) => (arg2: a) => boolean;
}
```
になります。

このEq型クラスをPureScriptで使うと以下のようになります。
```purs
isEq :: forall a. Eq a => a -> a -> Boolean
isEq a b = eq a b
```
この型宣言は「具体的に指定しないが、Eq型クラスの一員である`a`というデータ型の引数を2つ受け取ってBooleanを返す」という意味です。

これをTypeScriptに翻訳すると、
```ts
const isEq =
  <A>(Eq: Eq<A>) =>
  (a: A) =>
  (b: A) =>
    Eq.eq(a)(b);
```
になります。

ちなみに、PureScriptにも`==`は存在します。JavaScriptでは`==`は言語仕様ですが、PureScriptにとって`==`はただの`eq`関数のエイリアスです。

型クラスにはデフォルト実装が与えられていることもあり、自分で実装する必要がないこともあります。例えばEq型クラスに`notEqual`メソッドが存在していた場合、`notEqual = not eq`というように`eq`さえあれば導出できます。

# 型クラスのサブクラス化
次に値の大小関係を判定可能なデータ型を**Ord型クラス**で表すことを考えます。大小関係が判定可能ならば等値関係も判定可能ですから、Eq型クラスを利用してOrd型クラスを定義する、すなわち`Ord`を`Eq`のサブクラスにすると便利です。

PureScriptではOrd型クラスを次のように書きます。
```purs
data Ordering = LT | GT | EQ

class Eq a <= Ord a where
  compare :: a -> a -> Ordering
```

これをTypeScriptに翻訳するとこうなります。
```ts
type Ordering = LT | GT | EQ;
type LT = -1;
type GT = 1;
type EQ = 0;

interface Ord<a> extends Eq<a> {
  compare: (arg1: a) => (arg2: a) => Ordering;
}
```

`Ord`の使用方法は`Eq`のときと同じです。

# 高階型
(※多分この章は特に学術的に正しくないです)

「関数を返す関数」を高階関数と言います。カリー化された関数は高階関数です。
同様に(TSの文脈でいうと)「ジェネリクスを返すジェネリクス」を高階型と言います。
TypeScriptには高階型はありません[^1]。疑似コードで表すとこんな感じです。
```ts
type B = A<number><string>
```

[^1]: ハック的な方法を使えばエミュレートすることはできる

# まとめ
この記事ではカリー化、高階関数、高階型、型クラスなどの基本的な機能についてみてきました。紹介した手法はPureScriptでなくても活かせる考え方だと思います。また、関数型言語といえばモナドやファンクターという用語を聞いたことがある人もいるかもしれませんが、これらも結局は型クラスです。興味がある人は調べてみてください。

PureScriptは素晴らしい言語なので、人口が増えると嬉しいです。
