---
title: "HaskellのAlexとHappyでnode-semverパーサーを実装する"
emoji: "💬"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: ture
published_at: 2023-12-04 00:00
---

この記事は[Haskell Advent Calendar 2023](https://qiita.com/advent-calendar/2023/haskell)４日目の記事です。

最近node-semverのパーサーを作る機会があったので、HappyとAlexを用いたパーサーの作り方について紹介します。あまりnode-semverの仕様には立ち入らず、HappyとAlexの使い方について焦点を当てます。

パーサーの実装はここです。
https://github.com/Hagihara-A/node-semver-hs


# パーサの種類

パーサーの実装は主に手書きするか文法書から生成する２通りの方法があります。最も有名なのは再帰降下構文解析と、LR構文解析でしょうか。

PEGやパーサーコンビネータは再帰降下に属し、yaccやbisonはLR系の構文解析に属します。

[こちらのサイト](https://tratt.net/laurie/blog/2020/which_parsing_approach.html)では様々な構文解析法の分析をしています。箇条書きで抄訳したいと思います。

1. 再帰降下系
   1. わかりやすい
   2. 実はどの文法クラスに対応するか理論的に明らかになっていない
   3. 曖昧な文法を事前に検知できない
   4. 無限に先読みができるため、計算量の見積もりがしづらい
   5. 左結合の演算子のパースが素直にできない
   6. エラーリカバリーしやすい
2. LR系
   1. 曖昧な文法を事前に検知できる
   2. 先読みが瀬減されるので、計算量の見積もりができる(LR(1)なら$O(n)$)
   3. 文脈自由文法のうち、広めのサブセットを受理できる
   4. エラーリカバリーはやりにくい
   5. 演算子の優先度を考慮できる

この記事の筆者は、「再帰降下法は動的型付け言語のようにとっつきやすいが問題が起こりやすい手法で、 LR法は静的型付け言語のように難しいが問題を事前に検知しやすい手法だ」と喩えています。

HappyはLALR(1)パーサジェネレータです。LR(1)系の構文解析のアイデア自体は単純です。入力トークンを尺取り虫のように１つずつ見ていって最終的に構文木を生成します。この性質のおかげで、生成したパーサが$O(n)$で動くということを保証できます。

また、レキサージェネレータであるAlexと組み合わせてパーサを作っていきます。AlexとHappyはHaskell自体のパーサにも使われているため実績があります。

## レキサーの生成
Alexは`.x`ファイルに文法を定義することでレキサーを生成します。node-semverの文法定義はリポジトリにあるので、詳しくはそこを見てください。AlexにはWrapperといって、様々なインターフェースのレキサーを生成するオプションがあるのですが、最も基本的なインターフェースが重要です。Alexは結局のところ、以下のインターフェースのみを提供します。

```haskell
alexScan :: -- Alexの生成するレキサー
  AlexInput -> -- ユーザー定義の任意の入力
  Int -> -- レキサーの状態を表す数字。本質ではない
  AlexReturn action -- 返り値。actionはユーザー定義のトークンを返す関数

data AlexReturn action
  = AlexEOF
  | AlexError
      !AlexInput
  | AlexSkip
      !AlexInput
      !Int -- トークンの長さ
  | AlexToken
      !AlexInput -- 残りの入力
      !Int -- トークンの長さ
      action
```

alexScanの型を見ていただければわかるのですが、alexScanは入力と状態を受け取って、１トークンだけ読み進めます。このAPIを使ってモナド版のパーサーなどを作ることができます。

モナドパーサーには以下の型が使われることが多いようです。

```haskell
import Control.Monad.Trans.State.Strict (StateT)
type Alex a = StateT AlexState (Either String) a
alexMonadScan :: Alex Token -- Alexモナドで実行したalexScanの結果。ユーザーが書く。要はLexerの状態を受け取って１トークン返す。
```

## パーサーの生成

happyは`.y`拡張子の文法定義からパーサーを生成します。node-semver用の文法定義もリポジトリにあるので詳細はそちらをみてください。`%monad`と`%lexer`を設定すると、happyの生成するパーサーの型は以下になります。

```haskell
-- %tokentype { Token }
-- %name parse
-- %error { parseError }
-- %lexer { lexer } { TokenEOF }
-- %monad { Alex } { >>= } { pure }

parse :: Alex t -- tは構文木の型。happyが生成する
parseError :: Token -> Alex a -- エラーハンドリング関数。ユーザーが実装する
lexer :: (Token -> Alex a) -> Alex a -- レキサー関数。ユーザーが実装する

```

動作がイメージしづらいと思うので少し解説します。

`parse`はHappyの生成する構文解析器です。Alexは名前からして字句解析のためのモナドの印象が強いですが、実際には「パーサーとレキサーで必要なもの全般」を放り込んでおくモナドです。Alexモナドを使ってレキサーとパーサーで情報をやり取りすることができます。

`parseError`はわかりやすいと思います。今見ているトークンとパーサーの状態を参照してエラーを返します。

`lexer`はそのままレキサーですが、型が直感的ではないですね。第一引数は"１トークン受け取ってそれを消費するパーサー”です。これはhappyが渡します。ユーザーはこのトークンを消費する過程でLexerの状態を変更して文脈に依存した解析などをすることができます。happyは終了トークンが渡されるまでこの`lexer`を呼んで構文解析を行います。

# パーサーを動かしてみる

ということでパーサーができました。動かしてみましょう。`1.2.3`が`^1.2.3`を満たすことを確かめてみます。

```haskell
range = fromRight undefined (parseRange "^1.2.3") -- ^1.2.3 is >=1.2.3 <2.0.0-0
v_123 = version 1 2 3 [] [] 
print (satisfies v_123 range) -- True
```

期待通りに動きました。

