---
title: "Next.jsでFirebase Cloud Messaging"
emoji: "📬"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["firebase", "nextjs"]
published: false
---

Next.jsでFirebase Cloud Messaging(FCM)実装するメモです。

1. クライアント(今回はNextjs)で通知の許可を求める
1. クライアントでFCMのトークン取得
1. FCMのトークンをFirestoreに保存
1. FCMで通知を配信
1. クライアント(Nextjs)で通知受信＆表示

上のような構成でやります。各ステップでつまづく点があるので解説します。この記事ではトピックやデバイスグループなどは扱いません。なおドキュメントではわかりづらいですが、ServiceWorkerは最後の通知受信＆表示でのみ使います。他のところでは使いません。

# クライアントで通知の許可を求める

[Notification](https://developer.mozilla.org/ja/docs/Web/API/Notification)というWebAPIがあるのでこれを使います。

`Notification.permission`で現在の通知の許可・不許可のステータスがわかります。

まだ許可されていない場合は`Notification.requestPermission()`で許可を要求できます。


# クライアントでFCMのトークン取得

通知権限の要求が成功したら次にFCMのトークンを取得します。
コードは[これ](https://firebase.google.com/docs/cloud-messaging/js/client?hl=ja#access_the_registration_token) です。このドキュメントでServiceWorkerが云々と言ってるんですがここでは必要ないです。

# FCMのトークンをFirestoreに保存
クライアントで`firebase.messaging().getToken()`をして取得したトークンを普通にfirestoreに保存します。

[このページ](https://firebase.google.com/docs/cloud-messaging/manage-tokens?hl=ja)にトークンの管理方法があります。定期的にトークンとそのタイムスタンプを更新して、古くなったトークンを削除することが推奨されています。

# FCMで通知を配信
次にFCMで通知を配信します。ここではCloud Functionsを使います。

FCMトークンに宛てて通知を配信するには`sendMulticast()`を使って以下のようにできます。

```ts
import * as admin from 'firebase-admin'

const tokens = ['token1', 'token2']
const res = await admin.messaging().sendMulticast({
  tokens,
  notification: {
    title: 'テスト通知',
  },
})

res.responses.map((r, idx) => {
  const token = tokens[idx] // responsesは各tokensに対応している
  if (
    r.error?.code === 'UNREGISTERED' ||
    r.error?.code === 'INVALID_ARGUMENT'
  ) {
    // tokenが無効なため、削除するとよい
    deleteToken(token)
  }
})
```

`sendMulticast()`の返り値`res.responses`は`tokens`に対応しています。つまり`res.responses[idx]`は`tokens[idx]`のレスポンスです。また、`sendMulticast()`は１度に500トークンまでしか通知を配信できません。501件以上ある場合は複数回送信してください。

コード中の２つのエラーコードの時は２度とそのトークンが有効にならないことが保証されているため、削除しておくと良いでしょう。[参考](https://firebase.google.com/docs/cloud-messaging/manage-tokens?hl=ja#detect-invalid-token-responses-from-the-fcm-backend)

# クライアントで通知受信＆表示

以上の方法で配信した通知をクライアント側でハンドリングします。送れば勝手にプッシュ通知が表示されるわけではなく、クライアント側でも表示処理が必要です。この処理は、Webアプリがフォアグラウンドにあるときはアプリ自身が、バックグラウンドにあるときはServiceWorkerが行います。

## フォアグラウンドにある場合

フォアグラウンドにある場合は簡単です。
```ts
import firebase from 'firebase/app'

const unsubscribe = firebase.messaging().onMessage((payload) => {
  // ...
})

unsubscribe() // 購読解除
```

こうして受け取った通知をクライアントで表示します。これにも`Notification`APIを使います。試しにlocalhostなどでこのスクリプトを実行してみてください。

`Notification.requestPermission().then(()=>new Notification("test"))`

以下のように、権限の要求と通知の表示がされると思います。

![](https://storage.googleapis.com/zenn-user-upload/fd6a687a0c29-20220413.png)
![](https://storage.googleapis.com/zenn-user-upload/82860a238f6e-20220413.png)

このようにして通知を表示できます。

## バックグラウンドにある場合
バックグラウンドにある場合はServiceWorker(SW)でハンドリングするのでめんどくさいです。


まずSWの設定をしますが、その前にTypescriptを使っている人は`tsconfig.json`の`lib`に`"WebWorker"`を追加しておいてください。

next-pwaをインストールします。メインスレッドのスクリプトとSWのビルドプロセスは別です。そのため普通にNextjsを使う場合SWはモジュールバンドラやポリフィルを使って自力でビルドしなければいけませんが、next-pwaがあればいい感じにしてくれます。
```sh
yarn add next-pwa
```

次にnext-pwaを設定します。
```js:next.config.js
const withPWA = require('next-pwa')

module.exports = withPWA({
  pwa: {
    dest: 'public', // publicディレクトリにSWを出力する
    register: false // next-pwaが自動でSWを登録するのを無効にする
  }
})
```

next-pwaはデフォルトで`worker`ディレクトリにあるファイルをSWとして扱い、`public/sw.js`にビルド後のSWを出力します。

それではSWを書きます。

```ts:worker/index.ts
declare let self: ServiceWorkerGlobalScope

import firebase from 'firebase/app'
import 'firebase/messaging'

firebase.initializeApp({...config})
const messaging = firebase.messaging()

messaging.onBackgroundMessage((payload) => {
  const title = payload.notification?.title
  const body = payload.notification?.body
  self.registration.showNotification(title, {
    body,
  })
})
```

declare宣言でSWのおまじないをします。

フォアグラウンドにある場合と違い、SWで通知を表示にするには`self.registration.showNotification()`を使います。

このSWをメインスレッドから登録します。

```ts
const serviceWorkerRegistration = await navigator.serviceWorker.register(
  '/sw.js',
  {
    scope: 'firebase-cloud-messaging-push-scope', // デフォルトで指定されるスコープ。よくわからないが揃えておく。
  }
)
firebase.messaging().getToken({
  vapidKey: process.env.NEXT_PUBLIC_VAPID_KEY,
  serviceWorkerRegistration,
})
```

このスクリプトと、取得したトークンの保存処理を、`_app.ts`のuseEffectの中で呼び出します。


### (番外編)ESMでSWを書く
せっかくfirebase-js-sdk v9でESM対応したのでESMでSWを書いてみましょう。
```js:public/sw.js
import { initializeApp } from "https://esm.sh/firebase/app";
import {
  getMessaging,
  onBackgroundMessage,
} from "https://esm.sh/firebase/messaging/sw";

const firebaseApp = initializeApp({});
const messaging = getMessaging(firebaseApp);

console.log("hello serviceWorker!");

onBackgroundMessage(messaging, (payload) => {
  self.registration.showNotification("hello firebase");
});
```

個人的にはこっちをとても使いたいですが、ブラウザもTypescriptもまだサポートが追いついてないのと大人の事情で諦めました。。。