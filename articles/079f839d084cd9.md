---
title: "Haskellのお作法"
emoji: "⛳"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["haskell"]
published: true
published_at: 2023-12-11 00:00

---

Haskellはいいぞ。

Haskellはいい言語なんですが、プロジェクト管理に結構癖があるのでその話をします。

# ツールのインストール

開発ツールとしては
1. コンパイラ: GHC
2. ビルド: Cabal, Stack
3. Language Server: HLS

の４つが必要です。全部[ghcup](https://www.haskell.org/ghcup/)に任せてください。y押してるだけでいいです。

# プロジェクトの作成
次にプロジェクトを作ります。Haskellのプロジェクト管理にはCabalとStackが使われます。

Cabalは昔から使われてきたプロジェクト管理ツールです。プロジェクトのビルド、依存関係のインストール、テストやベンチマークの実行などができます。
Cabalだけでも一応プロジェクト管理はできるのですが、設定ファイル(`xxx.cabal`)が独自記法で書きづらいとか、複数パッケージの管理ができない、エラーメッセージがわかりづらいなどの問題があります。

そこでCabalの欠点を補うために開発されたのがStackです。Stackは内部的にCabalを使っています。Stackを使うとyamlで設定が書けるし、複数パッケージも管理しやすいです。そういうわけでCabalもStackも必要なのです。

プロジェクトの初期化は`stack init $package_name`で行います。こうすると`$package_name/`以下にパッケージを初期化してくれます。

いくつか重要な設定ファイルがあるので解説します。

## stack.yaml
stackには**プロジェクト**と**パッケージ**という概念があります。プロジェクトは複数パッケージを管理下に置けます。Web開発の文脈でいうモノレポみたいな感じです多分。

stack.yamlには色々かけるんですが、重要なのは`packages`フィールドです。

packagesフィールドには各パッケージへの相対パスをリストで記述します。おそらく初期状態では
```yaml
packages:
- .
```
となっていると思います。これはつまりプロジェクトのルートとパッケージのルートが一致しているということです。プロジェクトとパッケージの設定ファイルが混在するので正直あんまり好きではないです。

もしこのプロジェクトに新しくパッケージを登録する時には、そのパッケージまでの相対パスを追加します。新しいパッケージへのパスが`./hogehoge/`の場合は以下のようになります。

```yaml
packages:
- .
- ./hogehoge/
```

## `package.yaml`と`<package_name>.cabal`
`package.yaml`も`<package_name>.cabal`もパッケージの設定を記述します。2つも同じ役割の設定ファイルがあって紛らわしいのですが、`<package_name>.cabal`は全く気にしなくていいです。

stackはパッケージをビルドするときに`<package_name>.cabal`を`package.yaml`に基づいて自動で更新します。先述したようにcabalファイルは書きづらいけどcabalは捨てられないのでこのような仕組みになっています。gitignoreに`*.cabal`を追加してしまっていいです。

`package.yaml`は[hpack](https://github.com/sol/hpack?tab=readme-ov-file#documentation)というフォーマットに基づいています。仕様がわからなくなったらここを見に行ってください。cabalファイルは同じことを何回も指定しなければいけずめんどくさいのですが、hpackはDRYにかけていい感じです。

重要なフィールドとして、
1. library
2. executable(s)
3. tests
4. benchmarks

の４つがあります。`library`はその名の通り、Haskellコードとして再利用可能なライブラリとしての設定を記述します。

`executable`には実行可能なバイナリファイルをビルドするための設定を記述します。libraryとは別に依存パッケージを記述できるので、例えば CLIオプションをパースするパッケージをlibraryの依存に含めない（->ビルド時間短縮）ということができます。

`tests`と`benchmarks`の実態は`executables`です。`tests`も`benchmarks`も、テストとベンチマークのための実行可能バイナリをどうやってビルドするかという設定を記述するに過ぎません。例えば`benchmarks`にあるコードの実行時間を自動で計測するとか、`tests`にあるコードを自動でテストするかといった便利機能は一切ありません。`executables`フィールドに書いたとしても同じですが、わかりやすさのために別れているだけです。

# まとめ
結局cabalとstackの違いを説明するだけになってしまった。