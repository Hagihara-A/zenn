---
title: "å‹ãƒ¬ãƒ™ãƒ«ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã®ã‚¹ã‚¹ãƒ¡"
emoji: "ğŸ©º"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["typescript"]
published: true
---
# æº–å‚™
```ts
export type Extends<E, A> = A extends E ? true : false;
export type NotExtends<E, A> = A extends E ? false : true;
export type Exact<A, B> = Extends<A, B> extends true
  ? Extends<B, A> extends true
    ? true
    : false
  : false;
export type Match<E, A extends E> = Exact<E, Pick<A, keyof E>>;
export type Never<T> = T extends never ? true : false;

export type Assert<T extends true> = T;
```

# ãƒ†ã‚¹ãƒˆ
```ts

type ComplexType = { a: number; b?: number };
type _ = Assert<Match<{ a: number }, ComplexType>>; // OK
type _ = Assert<Match<{ a: number; b: number }, ComplexType>>; // Error
type _ = Assert<Match<{ b?: number }, ComplexType>>; // OK
type _ = Assert<Match<{ c: string[] }, ComplexType>>; // Error
```

ã‚ˆãä½¿ã†ã®ã¯`Match`ã§ã™ã€‚å·¦ã« __æœŸå¾…ã™ã‚‹éƒ¨åˆ†å‹__ ã€å³ã« __å®Ÿéš›ã®å‹__ ã‚’æ›¸ãã¾ã™ã€‚ä¾‹ãˆã°jestã™ã‚‹å‰/ã—ãŸå¾Œã«tscã‚’ã‹ã‘ã‚‹ã¨ã€å‹ã®ãƒã‚§ãƒƒã‚¯ãŒèµ°ã‚Šã¾ã™ã€‚`test`ã®ä¸­ã§Assertã™ã‚‹ã®ãŒã„ã„ã¨æ€ã„ã¾ã™ã€‚

æ³¨æ„ç‚¹ã¨ã—ã¦ã€vscodeã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®`tscofig.json`ã«æŒ‡å®šã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ä»¥å¤–ã¯vscodeã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆï¼Ÿï¼‰è¨­å®šã§ãƒã‚§ãƒƒã‚¯ã‚’ã‹ã‘ã‚‹ã®ã§ã€æ°—ã¥ã‹ãªã„ã†ã¡ã«StrictNullCheckãŒOffã«ãªã£ã¦ãŸã‚Šã—ã¦ãƒ†ã‚¹ãƒˆãŒå´©å£Šã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ç§ã¯vscodeãŒå‚ç…§ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…±é€šã®tsconfigã¨ã€globã‚’å¤‰ãˆãŸã ã‘ã®ãƒ“ãƒ«ãƒ‰ç”¨ã®tsconfig.buildã‚’ä½¿ã„åˆ†ã‘ã¦ã¾ã™ã€‚

# è›‡è¶³
ã“ã‚Œã ã‘ã ã¨å‘³æ°—ãªã„ã®ã§èªã‚Šã¾ã™ã€‚

ä»Š[fire-fuse](https://github.com/Hagihara-A/fire-fuse)ã¨ã„ã†å‹ãƒ‘ã‚ºãƒ«ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½œã£ã¦ã„ã‚‹ã®ã§ã™ãŒã€å‹ãŒè¤‡é›‘ã™ãã¦å‹ã«å¯¾ã—ã¦ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆçš„ãªã‚‚ã®ã‚’ã—ãŸããªã‚Šã¾ã—ãŸã€‚[tsd](https://github.com/SamVerschueren/tsd)ã¨ã„ã†å‹ãƒ†ã‚¹ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚ã‚‹ã®ã§ã™ãŒã€ã“ã‚Œã¯è¨­å®šãŒçµæ§‹è¤‡é›‘ãªä¸Šã€JSã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå®Ÿéš›ã«TSã®å‹ã¨ä¸€è‡´ã—ã¦ã„ã‚‹ã‹ã‚’èª¿ã¹ã‚‹ã®ã§ã€TSã®å‹ãŒæœŸå¾…ã—ãŸå‹ã«ãªã£ã¦ã„ã‚‹ã‹ã©ã†ã‹èª¿ã¹ãŸã„ã¨ã„ã†ç§ã®ã‚±ãƒ¼ã‚¹ã«ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“ã§ã—ãŸã€‚

:::details firefuseã§ä½¿ã£ã¦ã„ã‚‹å‹(å‚è€ƒ)
```ts
export type ConstrainedData<
  T extends DocumentData,
  C extends readonly firestore.QueryConstraint[],
  Mem extends Memory<T> = {
    rangeField: StrKeyof<T>;
    eqField: never;
    prevNot: false;
    prevArrcon: false;
    prevOr: false;
    prevOrderBy: false;
  }
> = C extends []
  ? T
  : C extends readonly [infer H, ...infer Rest]
  ? Rest extends readonly firestore.QueryConstraint[]
    ? H extends WhereConstraint<infer U, infer K, infer OP, infer V>
      ? T extends U
        ? OP extends GreaterOrLesserOp
          ? K extends Mem["rangeField"]
            ? ConstrainedData<Defined<T, K>, Rest, Mem & { rangeField: K }>
            : never
          : OP extends "=="
          ? ConstrainedData<
              T & { [L in K]-?: V },
              Rest,
              OR<Mem, { eqField: K }>
            >
          : OP extends "!="
          ? Mem["prevNot"] extends true
            ? never
            : K extends Mem["rangeField"]
            ? ConstrainedData<
                T & { [L in K]-?: Exclude<T[L], V> },
                Rest,
                OverWrite<Mem, { prevNot: true }> & { rangeField: K }
              >
            : never
          : OP extends "array-contains"
          ? Mem["prevArrcon"] extends true
            ? never
            : ConstrainedData<
                Defined<T, K>,
                Rest,
                OverWrite<Mem, { prevArrcon: true }>
              >
          : OP extends "array-contains-any"
          ? Mem["prevArrcon"] extends true
            ? never
            : Mem["prevOr"] extends true
            ? never
            : ConstrainedData<
                Defined<T, K>,
                Rest,
                OverWrite<Mem, { prevArrcon: true; prevOr: true }>
              >
          : OP extends "in"
          ? Mem["prevOr"] extends true
            ? never
            : V extends readonly T[K][]
            ? ConstrainedData<
                T & { [L in K]-?: V[number] },
                Rest,
                OR<OverWrite<Mem, { prevOr: true }>, { eqField: K }>
              >
            : never
          : OP extends "not-in"
          ? Mem["prevOr"] extends true
            ? never
            : Mem["prevNot"] extends true
            ? never
            : V extends readonly T[K][]
            ? ConstrainedData<
                T & { [L in K]-?: Exclude<T[L], V[number] | undefined> },
                Rest,
                OverWrite<Mem, { prevOr: true; prevNot: true }>
              >
            : never
          : never
        : never
      : H extends OrderByConstraint<infer K>
      ? Mem["prevOrderBy"] extends true
        ? ConstrainedData<Defined<T, K>, Rest, Mem>
        : K extends Mem["rangeField"]
        ? ConstrainedData<
            Defined<T, K>,
            Rest,
            OverWrite<Mem, { prevOrderBy: true }>
          >
        : never
      : H extends OtherConstraints
      ? ConstrainedData<T, Rest, Mem>
      : never
    : never
  : never;
```
:::

# ä½¿ç”¨ä¾‹
ã“ã‚“ãªæ„Ÿã˜ã§jestã®ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã¿ãŸã„ã«ã—ã¦æ›¸ã„ã¦ã„ã¾ã™ï¼ˆå®Ÿéš›ã«ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§ãƒ†ã‚¹ãƒˆã¯èµ°ã‚‰ãªã„ã§ã™ãŒï¼‰ã€‚
```ts
test("field of > exists", () => {
  const cs = [where("population", ">=", 1000)] as const;
  type T = CD<City, typeof cs>;

  type _ = Assert<Match<{ population: number }, T>>;
});

test("field of == exists", () => {
  const cs = [where("capital", "==", true as const)] as const;
  type T = CD<City, typeof cs>;
  type _ = Assert<Match<{ capital: true }, T>>;
});
```