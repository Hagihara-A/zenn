---
title: "ブラウザで俺の書いたReactをそのまま動かす"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react", "typescript"]
published: false
---

TC39が多くの新仕様を提案する一方で、同時にWebフロントエンドのビルドプロセスも複雑になってきています。

もはや以前のようにプログラマが書いたJavascriptがそのままブラウザで実行されることはありません。現代では私たちの書いたJavascriptはポリフィル・バンドラ・マングラ・トランスパイラなど多数のツールを用いて最適化を施すことが必須になっています。自分の命名した変数すら残っていないプログラムを納品することは誠実な態度と言えるのでしょうか？自分で読むことができないコードは自分が書いたと言えるのでしょうか。

つまりは気持ち悪いということです。ブラウザでは自分の読めるコードが動いてほしい。自動車がATになって自動で複雑な制御をして最適なギア比に変わるのはいいことなんだけど、でもたまにはMT車に乗って自分の責任でガシャコンしたいよね。自分の制御下にある範囲が増えると気持ちいいよね。そういうことです。プロダクションではビルドが必要ではあるけど、趣味のwebページくらいでは自分で読めるコードを動かしたいとは思いませんか？

そういうわけでこの記事の目標は**自分で読めるReactをブラウザで動かす**ことです。タイトルの"そのまま"はちょっと盛りました。

使うプリプロセスツールTypescriptだけです。モジュールバンドラは使いません。ESMとimport mapでブラウザに頑張ってもらいます。

幸いなことにTypescriptはjsxのトランスパイルをサポートしています。なのでTypescriptのビルド時に型チェックして、型落として、jsxをプレーンなjavascriptに変換してもらいます。このTSビルド後のコードを読めるようにします。

まずはプロジェクトを初期化します。

```sh
npm add react react-dom
npm add -D @types/react @types/react-dom typescript
```
`package.json`に`"type": "module"`を追加するのを忘れないでください。

次にTypescriptの初期化です。

```
npx tsc --init --target esnext --module esnext --rootDir ./src --outDir ./build --jsx react-jsxdev
```

Typescriptのnightlyビルドではmoduleにnode12(ESM)を使えますが、うまく動かない時があったので止めました。

次にindex.htmlを作ります。

```html
<!DOCTYPE html>

<head>
    <title>React As Is</title>
    <script type="importmap">
            {
            "imports": {
                "react": "https://esm.sh/react@17",
                "react-dom": "https://esm.sh/react-dom@17",
                "react/jsx-runtime": "https://esm.sh/react@17/jsx-runtime"
            }
            }
        </script>
    <script src="./build/main.js" type="module"></script>
</head>

<body>
    <div id="react-root"></div>
</body>

</html>
```

import mapをhtmlに埋め込んでいます。これはまだchromeが埋め込みしか対応してないからです。firefoxはそもそもimport mapに対応していません。

それではreactを書いていきます。

```ts:src/main.tsx
import { render } from "react-dom";
import { App } from "./mod.js";
const root = document.getElementById("react-root");
render(<App />, root);
```


```ts:src/mod.tsx
import { useState } from "react";

export const App = () => {
  const [name, setName] = useState("");
  return (
    <>
      <h2>Hello React</h2>
      <input onChange={(e) => setName(e.target.value)} />
      <p>Your name is...</p>
      <h3>{name.toUpperCase()}</h3>
    </>
  );
};
```
以上。`import { App } from "./mod.js";`の.jsを忘れないでください。

ローカルでの開発にはサーバーが必要なので適当にサーバーを書きますがめんどいので見たい人はリポジトリを見て下さい。

では準備ができたのでビルドします。

```js:build/mod.js
import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { useState } from "react";
export const App = () => {
    const [name, setName] = useState("");
    return (_jsxs(_Fragment, { children: [_jsx("h2", { children: "Hello React" }), _jsx("input", { onChange: (e) => setName(e.target.value) }), _jsx("p", { children: "Your name is..." }), _jsx("h3", { children: name.toUpperCase() })] }));
};
```

なんとか読めますね。あとはこれを静的ファイルとしてデプロイします。

デプロイしたのがこれです。EdgeかChromeの新しいやつじゃないと動きません。
https://hagihara-a.github.io/react-as-is/

ソースを見てもらえばわかるんですが、上で示したコードがそのままブラウザで動いています。さらにimport mapで指定した通りに、**ブラウザが**モジュールを読み込みに行っています。

これで**自分で読めるReactをブラウザで動かす**ことができました。FirefoxやSafariでは動かないし、EdgeとChromeでも古いバージョンでは動かないです。あと新しいJavascriptの構文を使うごとに対応するブラウザが減っていきます。完全に自己満足ですが、いつも使っているフレームワークの温かみを感じられるのでおすすめです。

ちなみに最初denoでやったら一瞬で終わったのでnodejsでやることにしました。みんなもDenoを使おう！

:::details 余談
romeがフロントエンドのツールチェインを統一することを目標にしていますが、denoもbundleとかfmtとかlintとかtestとか十分な機能を実装しているのでなんかもうそっちでいいかなと思っています。

ずっと開発中だし。。。
:::
