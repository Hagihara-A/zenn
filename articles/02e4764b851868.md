---
title: "FlexとBisonで実用的なパーサーを作る"
emoji: "💭"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["c", "flex", "bison", "parser"]
published: false
---

パーサージェネレーターと言えば Flex と Bison が有名です。しかし Flex と (特に)Bison のドキュメントは長くて複雑なため、ちょっと複雑なことをすると急に難易度が上がります。この記事ではこれらのツールを使って実用的なパーサーを作る手順を紹介します。基礎はあまり説明しないので、ドキュメントの最初あたりは読んでおくと良いです。

ドキュメント自体も少し探しにくいので以下にリンクを載せておきます。

- [Flex](https://westes.github.io/flex/manual/index.html#Top)
- [Bison](https://www.gnu.org/software/bison/manual/bison.html)

インストールには色々な方法があるのですが、私は Nix でインストールしました。Nix 全てのパッケージマネージャの上位互換なので(?)おすすめです。一度触ってみてください。

この記事で実装するパーサーは以下の機能を持ちます。

- reentrant
- トークンの位置の認識
- 構文木の構築

エラー回復は実装していません。やる気があったらやります。。。

私は以前 [Haskell で node-semver のパーサーを作ったことがある](https://github.com/Hagihara-A/node-semver-hs)ので今回もこのパーサーを作りますが、詳細な node-semver の文法の解説はしません。`^1.2.3`とか、`~2.3`とか`>=1.2.3-alpha.1+x86`とかの文字列をパースできたら成功と思ってもらってよいです。

node-semver を Flex と Bison で実装したリポジトリはこちらです。

https://github.com/Hagihara-A/practical-parser-in-flex-bison

# Lexer の実装

## Flex のオプション

まずは Lexer を作っていきます。Flex の文法定義ファイルには`.l`の拡張子をつけることが一般的です。モダンな`make`では`.l`を認識してよしなにやってくれるらしいです。

いきなりですが Flex の option では以下を指定します。

```lex:lex.l
%option reentrant header-file="lex.yy.h" noyywrap
%option bison-bridge bison-locations
```

1. `reentrant`: Lexer をスレッドセーフにする。これがないとグローバル変数を多用して治安が悪くなる。
2. `header-file="lex.yy.h"`: ヘッダファイルを生成する。
3. `noyywrap`: 入力が EOF になったときに復帰処理をしない。(単純化のため)
4. `bison-bridge`, `bison-locations`: bison と連携できる Lexer を生成する。

このオプションを指定すると Flex は以下のシグネチャを持つ Lexer を生成します。

```c
int yylex ( YYSTYPE * lvalp, YYLTYPE * llocp, yyscan_t scanner );
```

yylex は呼び出されるとトークンを 1 つ認識するまで読み進め、トークンの種類を表す`int`を返します。数字や識別子などの意味値を持つトークンは、引数の`YYSTYPE * lvalp`を yylex の中で書き換えることで意味を記録します。`YYLTYPE * llocp`はトークンの位置情報を受け渡します。`yyscan_t scanner`は Lexer と Parser の状態を保存しておく変数で、`reentrant`オプションによって生成されます。これらの引数をつかって Flex と Bison で情報をやり取りします。

## 文法の定義

Flex の文法は`正規表現 {アクション}`という単純な構造をしています。例えば以下は正しい Flex の文法定義です。

```
"." {return TK_DOT;}
"+" {return TK_PLUS;}
[1-9][0-9]*|0 {return TK_NUM;}
[:alnum:]+ {return TK_ID;}
```

ここで`TK_DOT`や`TK_PLUS`などはどこか適切な場所で定義した enum とします。Flex 自体にこの enum を生成する仕組みは備わっていません。あとで見ますが、実はこのトークン種別を表す enum は Bison 側で定義します。

入力が正規表現に一致するとアクションが実行されます。この例ではトークン種別の enum を return していますが、アクションを複数行書くことも、return 以外のことをすることも可能です。

なお、正規表現の間に空白を入れることはできません。空白を挟むと以降すべての文字列がアクションとして解釈されます。実のところ C のコードを囲う`{}`はなくても良いのですが、わかりやすさのために着けておくことにします。

Flex はデフォルトでは文法にマッチしない入力をおこなってもエラーになることはなく、マッチしない文字列を標準出力に吐き出して入力の読み込みを続けます。一方でアクションがないルールは単純に読み捨てられます。

## 意味値の記録

実は上記の文法には欠陥があります。それは、`[1-9][0-9]*|0 {return TK_NUM;}`というルールは数字にマッチするにもかかわらず、その値の情報を捨ててしまっていることです。このままでは`TK_NUM`という種別はわかりますが、肝心の値がわかりません。

この値を記録するのが先述した`YYSTYPE * lvalp`引数です。ここで`YYSTYPE`はどこか適切な場所で定義された以下の型とします。

```c
typedef union {
    int digit;
    char *id;
} YYSTYPE;
```

この引数を用いて上記の文法を書き換えます。

```
"." {return TK_DOT;}
"+" {return TK_PLUS;}
[1-9][0-9]*|0 {
    yylval->digit = atoi(yytext);
    return TK_NUM;}
[:alnum:]+ {
    yylval->id = strndup(yytext, yyleng);
    return TK_ID;}
```

`yytext`と`yyleng`はそれぞれマッチした文字列とその長さを表す変数で、実体は`scanner->yytext_r`のようなマクロで定義されています。

このようにすることでトークンの意味値を保存することができます。

## Start Condition

同じ文字列でも文脈によって別の意味を持つことがあります。C 言語で代表的な例は`*`です。

```c
int *a;
```

```c
int a = 1 * 2;
```

上記のプログラムでは`*`がポインタ宣言と乗算演算子の 2 つの意味を持ちます。つまり`*`は、型宣言中はポインタとして、式中では乗算の演算子として解釈されます。

こうした文脈依存のトークン(のある程度)は Start Condition を用いて扱うことができます。Start Condition はルールの on/off を切り替えられる機能で、以下のように宣言します。

```
%s ID EXPR

%%

<TYPE>"*" {return TK_PTR;}
<EXPR>"*" {return TK_MUL;}
```

この`<TYPE>`と`<EXPR>`がStart Conditionです。Start Conditionが`<TYPE>`のときは`*`をポインタ宣言トークンとして認識し、`<EXPR>`の時は乗算記号として認識します。Flexで提供される`BEGIN`マクロを使って、`BEGIN(TYPE);`などのようにアクション内でStart Conditionを変更することができます。

詳細はドキュメントをごらんください。

## 位置の追跡
