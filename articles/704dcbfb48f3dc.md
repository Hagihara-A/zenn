---
title: "SemVerのパーサーをHaskellで実装する"
emoji: "✂︎"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["haskell"]
published: false
---

この記事では、nodejsでパッケージバージョニングのデファクトスタンダードとなっている[node-semver](https://github.com/npm/node-semver)をHaskellで再実装します。
再実装を通して、SemVerとnode-semverの違いや、HaskellのパーサジェネレータであるHappyとAlexの使用方法について紹介します。

# SemVer
SemVerはよく知られている通りバージョンの違いでパッケージの互換性を表現し、５つの部分で構成されます。

最も基本的なバージョンは３つの数字をドットで繋いで表現します。例えば`1.2.3`です。

バージョン番号に加えて、プレリリースやビルドを区別するために識別子をつなげることができます。例えば`1.2.3-alpha+linux`です。この場合プレリリース識別子が`alpha`で、ビルド識別子が`linux`です。

さらに、これらの識別子はドットでつなげることができます。つまり、`1.2.3-alpha.1`や`1.2.3-alpha.2`といったバージョンがあり得ます。

SemVerではこのようなバージョンの定義と、その比較方法を定義しています。比較方法について詳しくは説明しませんが、先ほどの例でいうと`1.2.3-alpha = 1.2.3-alpha+linux < 1.2.3-alpha.1 < 1.2.3-alpha.2 < 1.2.3`　というように並べ替えられます。

ここまで説明した概念は集合の概念を用いて整理できます。

上記の定義に従って得られるSemVer全体の集合$S$を考えます。$S$の元はSemVerです。ここで、任意の２つの元を$S$からとってくると、この２つの順序を必ず決定することができます。これはまさに全順序集合です ^[若干怪しいが都合がいいのでとりあえずそういうことにしておく]。

再度強調しますが、元々のSemVerで定義しているのは**これだけ**です。他には何も定義していません。


# node-semver
ここまでSemVerの仕様について見てきました。SemVerはバージョンの表し方と比較方法のみを定義していることを紹介しました、

しかしこの定義だけだと実用上不便が生じます。例えば`1.2.3以上かつ2.0.0未満`という**バージョンの範囲**を表したいときです。このようなバージョンの範囲を表す記法はSemVerにはありません。SemVerだけでは、あるバージョン$s_1$が与えられたとき、この$s_1$が`1.2.3以上かつ2.0.0未満`かどうかという判定をすることしかできません。

バージョンの範囲を表す記法やその意味は各言語、各パッケージマネージャでそれぞれに実装されています。nodejsでは`node-semver`が最もよく使われているでしょう。

例えばnode-semverは`^1.2.3`や`~1.2.3`, `>1.2.3`というようにバージョンの範囲を表します。これはSemVerの仕様外であるため、他のパッケージマネージャに持って行ったときに期待通り動く保証はどこにもありません。