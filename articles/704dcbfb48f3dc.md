---
title: "SemVerのパーサーをHaskellで実装する"
emoji: "📦"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["npm", "haskell"]
published: false
---

この記事ではSemVerとnode-semverの違いや、HaskellのパーサジェネレータであるHappyとAlexの使用方法について紹介します。

パーサーの実装はここです。
https://github.com/Hagihara-A/node-semver-hs

# SemVer
SemVerはよく知られている通りバージョンの違いでパッケージの互換性を表現し、５つの部分で構成されます。

最も基本的なバージョンは３つの数字をドットで繋いで表現します。例えば`1.2.3`です。

バージョン番号に加えて、プレリリースやビルドを区別するために識別子をつなげることができます。例えば`1.2.3-alpha+linux`です。この場合プレリリース識別子が`alpha`で、ビルド識別子が`linux`です。

さらに、これらの識別子はドットでつなげることができます。つまり、`1.2.3-alpha.1`や`1.2.3-alpha.2`といったバージョンも可能です。

SemVerではこのようなバージョンの定義と、その比較方法を定義しています。比較方法について詳しくは説明しませんが、先ほどの例でいうと`1.2.3-alpha = 1.2.3-alpha+linux < 1.2.3-alpha.1 < 1.2.3-alpha.2 < 1.2.3`　というように並べ替えられます。

ここまで説明した概念は集合の概念を用いて整理できます。

上記の定義に従って得られるSemVer全体の集合$S$を考えます。$S$の元はSemVerです。ここで、任意の２つの元を$S$からとってくると、この２つの順序を必ず決定することができます。これはまさに全順序集合です ^[若干怪しいが都合がいいのでとりあえずそういうことにしておく]。

再度強調しますが、元々のSemVerで定義しているのは**これだけ**です。他には何も定義していません。


# node-semver
ここまでSemVerの仕様について見てきました。SemVerはバージョンの表し方と比較方法のみを定義していることを紹介しました、

しかしこの定義だけだと実用上不便が生じます。例えば`1.2.3以上かつ2.0.0未満`という**バージョンの範囲**を表したいときです。このようなバージョンの範囲を表す記法はSemVerにはありません。SemVerだけでは、あるバージョン$s_1$が与えられたとき、この$s_1$が`1.2.3以上かつ2.0.0未満`かどうかという判定をすることしかできません。

node-semverでは`^1.2.3`や`~1.2.3`, `>1.2.3`というようにバージョンの範囲を表します。これはSemVerの仕様外であるため、他のパッケージマネージャに持って行ったときに期待通り動く保証はどこにもありません。

バージョン範囲を表すためには、上限と下限、そしてそれらを含むかどうかを指定すれば十分です。つまりすべてのnode-semverの記法は上限と下限の指定のショートカットです。

node-semverでは様々な方法でバージョンの範囲を指定することができます。

## 基本的なバージョン範囲
node-semverでは
1. `<`
2. `<=`
3. `>`
4. `>=`
5. `=`

の５つの記号を使用できます。例えば`>=1.2.7`などです。わかりやすいですね。ちなみに`1.2.3`とかくと`=1.2.3`のことだと解釈されます。等号はあってもなくてもいいです。いいんじゃないでしょうか。

## 範囲の組み合わせ
バージョン範囲を組み合わせるためにはOR(範囲の和)とAND(範囲の積)が必要です。node-semverでは`||`をOR、空白をANDをとる演算子として用います。`||`は演算子の中で一番優先度が低いです。
例えば`1.2.7 || >=1.2.9 <2.0.0`は。`1.2.7`, `1.2.9`, `1.4.6`を含みますが、`1.2.8`や`2.0.0`は含みません。パーサー実装者としては空白ではなく`&&`あたりをAND演算子として使って欲しかったところです。ちなみに、`>=   1.2.3`のように、比較記号とバージョンの間に空白を入れると読み飛ばされます。`>=   1 . 2 . 3`のようにするとエラーです。

ここまでで単純な範囲指定と、それらを組み合わせる記法を見てきました。単純な記法だけでやりたいことはできるのですが、利用者の便利のためにより高度な記法が存在します。

## 高度な範囲指定方法
### ハイフン
バージョン範囲の上限と下限を一度に指定するためにハイフンを使うことができます。例えば`1.2.3 - 2.3.4`です。

ここでハイフンは識別子のセパレータとしても使えることを思い出してください。つまり`1.2.3-2.3.4`は範囲ではなく、ただ一つのバージョン（またはそのバージョンのみを元とする区間）を表します。node-semverではハイフンの前後に空白があるかどうかで判断しているようですが、なんと空白はAND演算子としても用いられています。めんどくさいですね。

### チルダ
SemVerの前にチルダを置くと、「３桁目のバージョンはなんでも良い」という範囲を表すことができます。例えば`~1.2.3`は`>=1.2.3 <1.3.0-0`です。

### キャレット
同じようにキャレットを置くと、「一番左の非ゼロの番号のみを固定」した範囲を表すことができます。例えば`^1.2.3`は`>=1.2.3 <2.0.0-0`と同じ意味になります。一方で`^0.2.3`は`>=0.2.3 <0.3.0-0`です。最も多くpackage.jsonで見る記法だと思います。

### 部分的なバージョン指定
バージョン番号のある桁がなんでも良いことを表すために、`x`, `X`, `*`を使うことができます。例えば`1.2.x`や`1.*.x`などです。さらにこれらの記号は省略することもできるので、`1.2`や`1`も正しい文法です。ちなみに`1.*.3`もOKです。この場合`1.*.*`と同じ意味になります。

これは実装する視点で見ると本当にめんどくさいです。単体だとそれほどでもないですが、これまでに紹介した記法と組み合わせるとパターンが莫大に増えます。

例えばハイフンと組み合わせます。`1.2 - 2.3.4`としましょう。これは`>=1.2.0 <=2.3.4`になります。0埋めするだけなので直感的ですね。では`1.2.3 - 2.3`はどうなるでしょう？僕の直感的には`1.2.3 - 2.3.0`になってほしいですが、これは`>=1.2.3 <2.4.0-0`になります。う、うーん。まぁ省略した桁はなんでも良いのでアルゴリズム的には一貫しているのですが、複雑です。

次にチルダでやってみましょう。例えば`~1.2`です。実はこの場合はチルダをつけてもつけなくても変わりません。では`~1`はどうでしょう？これもまた意味は変わりません。そうですか。。。

では単純な比較記号と組み合わせてみます。次の２つの不等式、どちらが成り立つでしょうか？

1. `1.2.3 <= 1`
2. `1.2.3 >= 1`

なんとこれは**どちらも成り立ちます**。おかしいのは`1.2.3 <= 1`です。前述した通り「省略した桁はなんでも良い」ので、`<=1`は実質的に`<=1.999.999`になります ^[わかりやすさのため999で桁の最大値を表しています]。

## まとめ
様々なnode-semverの記法を見てきました。SemVerとの違いを表で整理してみます。

|               | node-semver | SemVer |
| ------------- | ----------- | ------ |
| 1.2.3         | ✅           | ✅      |
| =1.2.3        | ✅           | ❌      |
| 1.2.3 - 2.3.4 | ✅           | ❌      |
| 1.2.3-2.3.4   | ✅           | ✅      |
| ~1.2.3        | ✅           | ❌      |
| ^1.2.3        | ✅           | ❌      |
| 1.2           | ✅           | ❌      |

`1.2.3`はSemVerでもありますし、`=1.2.3`というバージョン範囲でもあります。


余談ですが、node-semverは`~>1.2.3`のような仕様外のバージョンもパースしてしまうバグ？があります。

# パーサの実装

色々node-semverの難しいところを見てきました。この節からはこの仕様に準拠したパーサを実装していきます。パーサーの実装は主に手書きするか文法書から生成する２通りの方法があります。最も有名なのは再帰降下構文解析と、LR構文解析でしょうか。

[こちらのサイト](https://tratt.net/laurie/blog/2020/which_parsing_approach.html)では様々な構文解析法の分析をしています。箇条書きで抄訳したいと思います。

1. 再帰降下
   1. わかりやすい
   2. 実はどの文法クラスに対応するか理論的に明らかになっていない
   3. 曖昧な文法を事前に検知できない
   4. 左結合の演算子のパースが素直にできない
   5. エラーリカバリーしやすい
2. LR
   1. 曖昧な文法を事前に検知できる
   2. 計算量の見積もりができる(LR(1)なら$O(n)$)
   3. 文脈自由文法のうち、広めのサブセットを受理できる
   4. エラーリカバリーはやりにくい
   5. 演算子の優先度を考慮できる

この記事の筆者は、「再帰降下法は動的型付け言語のようにとっつきやすいが問題が起こりやすい手法で、 LR法は静的型付け言語のように難しいが問題を事前に検知しやすい手法だ」と喩えています。

要するにLR法が良さそうです。

幸いなことにHappyはHaskellのLR(1)パーサジェネレータです。LR(1)構文解析のアイデア自体は単純です。入力トークンを尺取り虫のように１つずつ見ていって最終的に構文木を生成します。この性質のおかげで、生成したパーサが$O(n)$で動くということを保証できます。

また、レキサージェネレータであるAlexと組み合わせてパーサを作っていきます。AlexとHappyはHaskell自体のパーサにも使われているため実績があります。

## レキサーの生成
Alexは`.x`ファイルに文法を定義することでレキサーを生成します。node-semverの文法定義はリポジトリにあるので、詳しくはそこを見てください。AlexにはWrapperといって、様々なインターフェースのレキサーを生成するオプションがあるのですが、最も基本的なインターフェースが重要です。Alexは結局のところ、以下のインターフェースのみを提供します。

```haskell
alexScan :: -- Alexの生成するレキサー
  AlexInput -> -- ユーザー定義の任意の入力
  Int -> -- レキサーの状態を表す数字。本質ではない
  AlexReturn action -- 返り値。actionはユーザー定義のトークンを返す関数

data AlexReturn action
  = AlexEOF
  | AlexError
      !AlexInput
  | AlexSkip
      !AlexInput
      !Int -- トークンの長さ
  | AlexToken
      !AlexInput -- 残りの入力
      !Int -- トークンの長さ
      action
```

alexScanの型を見ていただければわかるのですが、alexScanは呼び出されるごとに１トークンだけ読み取って返します。このAPIを使ってモナド版のパーサーなどを作ることができます。

パーサーには以下の型が使われることが多いようです。

```haskell
import Control.Monad.Trans.State.Strict (StateT)
type Alex a = StateT AlexState (Either String) a
alexMonadScan :: Alex Token -- Alexモナドで実行したalexScanの結果。ユーザーが書く。要はLexerの状態を受け取って１トークン返す。
```

## パーサーの生成

happyは`.y`拡張子の文法定義からパーサーを生成します。node-semver用の文法定義もリポジトリにあるので詳細はそちらをみてください。`%monad`と`%lexer`を設定すると、happyの生成するパーサーの型は以下になります。

```haskell
-- %tokentype { Token }
-- %name parse
-- %error { parseError }
-- %lexer { lexer } { TokenEOF }
-- %monad { Alex } { >>= } { pure }

parse :: Alex t -- tは構文木の型。happyが生成する
parseError :: Token -> Alex a -- エラーハンドリング関数。ユーザーが実装する
lexer :: (Token -> Alex a) -> Alex a -- レキサー関数。ユーザーが実装する

```

動作がイメージしづらいと思うので少し解説します。

`parse`はHappyの生成する構文解析器です。Alexは名前からして字句解析のためのモナドの印象が強いですが、実際には「パーサーとレキサーで必要なもの全般」を放り込んでおくモナドです。Alexモナドを使ってレキサーとパーサーで情報をやり取りすることができます。

`parseError`はわかりやすいと思います。今見ているトークンとパーサーの状態を参照してエラーを返します。

`lexer`はそのままレキサーですが、型が直感的ではないですね。第一引数は"１トークン受け取ってそれを消費するパーサー”です。これはhappyが渡します。ユーザーはこのトークンを消費する過程でLexerの状態を変更して文脈に依存した解析などをすることができます。happyは終了トークンが渡されるまでこの`lexer`を呼んで構文解析を行います。

# パーサーを動かしてみる

ということでパーサーができました。動かしてみましょう。`1.2.3`が`^1.2.3`を満たすことを確かめてみます。

```haskell
range = fromRight undefined (parseRange "^1.2.3") -- ^1.2.3 is >=1.2.3 <2.0.0-0
v_123 = version 1 2 3 [] [] 
print (satisfies v_123 range) -- True
```

期待通りに動きました。

# まとめ
この記事では SemVerとnode-semverの違いを紹介し、AlexとHappyを使ったパーサーを実装について少しだけ触れました。Rustが盛り上がってきていますが、Haskellも同じ系統に属しています。良い言語なので触ってみてください。
